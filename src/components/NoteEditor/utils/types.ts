// eslint-disable-next-line no-unused-vars
import { ToolbarButtonInfo } from './ToolbarButtonUtils';

export interface ToolbarButtonInfos {
	[key: string]: ToolbarButtonInfo;
}

export interface NoteEditorProps {
	// style: any;
	noteId: string;
	themeId: number;
	dispatch: Function;
	selectedNoteIds: string[];
	selectedFolderId: string;
	notes: any[];
	watchedNoteFiles: string[];
	isProvisional: boolean;
	editorNoteStatuses: any;
	syncStarted: boolean;
	bodyEditor: string;
	folders: any[];
	notesParentType: string;
	selectedNoteTags: any[];
	lastEditorScrollPercents: any;
	selectedNoteHash: string;
	searches: any[];
	selectedSearchId: string;
	customCss: string;
	noteVisiblePanes: string[];
	watchedResources: any;
	highlightedWords: any[];
	toolbarButtonInfos: ToolbarButtonInfo[];
	setTagsToolbarButtonInfo: ToolbarButtonInfo;
	richTextBannerDismissed: boolean;
}

export interface NoteBodyEditorProps {
	style: any;
	ref: any;
	themeId: number;
	content: string;
	contentKey: string;
	contentMarkupLanguage: number;
	contentOriginalCss: string;
	onChange(event: OnChangeEvent): void;
	onWillChange(event: any): void;
	onMessage(event: any): void;
	onScroll(event: any): void;
	markupToHtml: Function;
	htmlToMarkdown: Function;
	allAssets: Function;
	disabled: boolean;
	dispatch: Function;
	noteToolbar: any;
	setLocalSearchResultCount(count: number): void;
	searchMarkers: any;
	visiblePanes: string[];
	keyboardMode: string;
	resourceInfos: ResourceInfos;
	locale: string;
	onDrop: Function;
	noteToolbarButtonInfos: ToolbarButtonInfo[];
	fontSize: number;
}

export interface FormNote {
	id: string;
	title: string;
	body: string;
	parent_id: string;
	is_todo: number;
	bodyEditorContent?: any;
	markup_language: number;
	user_updated_time: number;
	encryption_applied: number;

	hasChanged: boolean;

	// Getting the content from the editor can be a slow process because that content
	// might need to be serialized first. For that reason, the wrapped editor (eg TinyMCE)
	// first emits onWillChange when there is a change. That event does not include the
	// editor content. After a few milliseconds (eg if the user stops typing for long
	// enough), the editor emits onChange, and that event will include the editor content.
	//
	// Both onWillChange and onChange events include a changeId property which is used
	// to link the two events together. It is used for example to detect if a new note
	// was loaded before the current note was saved - in that case the changeId will be
	// different. The two properties bodyWillChangeId and bodyChangeId are used to save
	// this info with the currently loaded note.
	//
	// The willChange/onChange events also allow us to handle the case where the user
	// types something then quickly switch a different note. In that case, bodyWillChangeId
	// is set, thus we know we should save the note, even though we won't receive the
	// onChange event.
	bodyWillChangeId: number;
	bodyChangeId: number;


	// Note with markup_language = HTML have a block of CSS at the start, which is used
	// to preserve the style from the original (web-clipped) page. When sending the note
	// content to TinyMCE, we only send the actual HTML, without this CSS. The CSS is passed
	// via a file in pluginAssets. This is because TinyMCE would not render the style otherwise.
	// However, when we get back the HTML from TinyMCE, we need to reconstruct the original note.
	// Since the CSS used by TinyMCE has been lost (since it's in a temp CSS file), we keep that
	// original CSS here. It's used in formNoteToNote to rebuild the note body.
	// We can keep it here because we know TinyMCE will not modify it anyway.
	originalCss: string;
}

export function defaultFormNote(): FormNote {
	return {
		id: '',
		parent_id: '',
		title: '',
		body: '',
		is_todo: 0,
		markup_language: 1,
		bodyWillChangeId: 0,
		bodyChangeId: 0,
		originalCss: '',
		hasChanged: false,
		user_updated_time: 0,
		encryption_applied: 0,
	};
}

export interface ResourceInfo {
	localState: any;
	item: any;
}

export interface ResourceInfos {
	[index: string]: ResourceInfo;
}

export enum ScrollOptionTypes {
	None = 0,
	Hash = 1,
	Percent = 2,
}

export interface ScrollOptions {
	type: ScrollOptionTypes;
	value: any;
}

export interface OnChangeEvent {
	changeId: number;
	content: any;
}

export interface EditorCommand {
	name: string;
	value: any;
}

export interface CommandValue {
	name: string;
	args?: any; // Should be an array for CodeMirror or an object for TinyMCE
	ui?: boolean; // For TinyMCE only
	value?: any; // For TinyMCE only
}



// AUTO-GENERATED BY packages/tools/generate-database-types.js

// This file was generated by a tool.
// Rerun sql-ts to regenerate this file.
export interface AlarmEntity {
	'id'?: number | null;
	'note_id'?: string;
	'trigger_time'?: number;
	'type_'?: number;
  }
  export interface DeletedItemEntity {
	'id'?: number | null;
	'item_type'?: number;
	'item_id'?: string;
	'deleted_time'?: number;
	'sync_target'?: number;
	'type_'?: number;
  }
  export interface FolderEntity {
	'id'?: string | null;
	'title'?: string;
	'created_time'?: number;
	'updated_time'?: number;
	'user_created_time'?: number;
	'user_updated_time'?: number;
	'encryption_cipher_text'?: string;
	'encryption_applied'?: number;
	'parent_id'?: string;
	'is_shared'?: number;
	'type_'?: number;
  }
  export interface ItemChangeEntity {
	'id'?: number | null;
	'item_type'?: number;
	'item_id'?: string;
	'type'?: number;
	'created_time'?: number;
	'source'?: number;
	'before_change_item'?: string;
	'type_'?: number;
  }
  export interface KeyValueEntity {
	'id'?: number | null;
	'key'?: string;
	'value'?: string;
	'type'?: number;
	'updated_time'?: number;
	'type_'?: number;
  }
  export interface MasterKeyEntity {
	'id'?: string | null;
	'created_time'?: number;
	'updated_time'?: number;
	'source_application'?: string;
	'encryption_method'?: number;
	'checksum'?: string;
	'content'?: string;
	'type_'?: number;
  }
  export interface MigrationEntity {
	'id'?: number | null;
	'number'?: number;
	'updated_time'?: number;
	'created_time'?: number;
	'type_'?: number;
  }
  export interface NoteResourceEntity {
	'id'?: number | null;
	'note_id'?: string;
	'resource_id'?: string;
	'is_associated'?: number;
	'last_seen_time'?: number;
	'type_'?: number;
  }
  export interface NoteTagEntity {
	'id'?: string | null;
	'note_id'?: string;
	'tag_id'?: string;
	'created_time'?: number;
	'updated_time'?: number;
	'user_created_time'?: number;
	'user_updated_time'?: number;
	'encryption_cipher_text'?: string;
	'encryption_applied'?: number;
	'is_shared'?: number;
	'type_'?: number;
  }
  export interface NoteEntity {
	'id'?: string | null;
	'parent_id'?: string;
	'title'?: string;
	'body'?: string;
	'created_time'?: number;
	'updated_time'?: number;
	'is_conflict'?: number;
	'latitude'?: number;
	'longitude'?: number;
	'altitude'?: number;
	'author'?: string;
	'source_url'?: string;
	'is_todo'?: number;
	'todo_due'?: number;
	'todo_completed'?: number;
	'source'?: string;
	'source_application'?: string;
	'application_data'?: string;
	'order'?: number;
	'user_created_time'?: number;
	'user_updated_time'?: number;
	'encryption_cipher_text'?: string;
	'encryption_applied'?: number;
	'markup_language'?: number;
	'is_shared'?: number;
	'type_'?: number;
  }
  export interface NotesNormalizedEntity {
	'id'?: string;
	'title'?: string;
	'body'?: string;
	'user_created_time'?: number;
	'user_updated_time'?: number;
	'is_todo'?: number;
	'todo_completed'?: number;
	'parent_id'?: string;
	'latitude'?: number;
	'longitude'?: number;
	'altitude'?: number;
	'source_url'?: string;
	'type_'?: number;
  }
  export interface ResourceLocalStateEntity {
	'id'?: number | null;
	'resource_id'?: string;
	'fetch_status'?: number;
	'fetch_error'?: string;
	'type_'?: number;
  }
  export interface ResourceEntity {
	'id'?: string | null;
	'title'?: string;
	'mime'?: string;
	'filename'?: string;
	'created_time'?: number;
	'updated_time'?: number;
	'user_created_time'?: number;
	'user_updated_time'?: number;
	'file_extension'?: string;
	'encryption_cipher_text'?: string;
	'encryption_applied'?: number;
	'encryption_blob_encrypted'?: number;
	'size'?: number;
	'is_shared'?: number;
	'type_'?: number;
  }
  export interface ResourcesToDownloadEntity {
	'id'?: number | null;
	'resource_id'?: string;
	'updated_time'?: number;
	'created_time'?: number;
	'type_'?: number;
  }
  export interface RevisionEntity {
	'id'?: string | null;
	'parent_id'?: string;
	'item_type'?: number;
	'item_id'?: string;
	'item_updated_time'?: number;
	'title_diff'?: string;
	'body_diff'?: string;
	'metadata_diff'?: string;
	'encryption_cipher_text'?: string;
	'encryption_applied'?: number;
	'updated_time'?: number;
	'created_time'?: number;
	'type_'?: number;
  }
  export interface SettingEntity {
	'key'?: string | null;
	'value'?: string | null;
	'type_'?: number;
  }
  export interface SyncItemEntity {
	'id'?: number | null;
	'sync_target'?: number;
	'sync_time'?: number;
	'item_type'?: number;
	'item_id'?: string;
	'sync_disabled'?: number;
	'sync_disabled_reason'?: string;
	'force_sync'?: number;
	'item_location'?: number;
	'type_'?: number;
  }
  export interface TableFieldEntity {
	'id'?: number | null;
	'table_name'?: string;
	'field_name'?: string;
	'field_type'?: number;
	'field_default'?: string | null;
	'type_'?: number;
  }
  export interface TagEntity {
	'id'?: string | null;
	'title'?: string;
	'created_time'?: number;
	'updated_time'?: number;
	'user_created_time'?: number;
	'user_updated_time'?: number;
	'encryption_cipher_text'?: string;
	'encryption_applied'?: number;
	'is_shared'?: number;
	'parent_id'?: string;
	'type_'?: number;
  }
  export interface TagsWithNoteCountEntity {
	'id'?: string | null;
	'title'?: string | null;
	'created_time'?: number | null;
	'updated_time'?: number | null;
	'note_count'?: any | null;
	'type_'?: number;
  }
  export interface VersionEntity {
	'version'?: number;
	'table_fields_version'?: number;
	'type_'?: number;
  }
